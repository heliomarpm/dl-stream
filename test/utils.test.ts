// Generated by CodiumAI

import { FileHelper, SpeedFormatter, uuidv4 } from "../src/core/utils";

import fs from 'fs';
import util from 'util';


describe('Utils', () => {

	describe('uuidv4', () => {

		// Returns a string of length 32
		it('should return a string of length 32', () => {
			const result = uuidv4();
			expect(result.length).toBe(32);
		});

		// Returns a unique string on each call
		it('should return a unique string on each call', () => {
			const result1 = uuidv4();
			const result2 = uuidv4();
			expect(result1).not.toBe(result2);
		});

		// None
		it('should have no specific behavior to test', () => {
			// No specific behavior to test
			expect(true).toBe(true);
		});

		// function execution time is less than 1ms
		it('should have a function execution time less than 1ms', () => {
			const startTime = performance.now();
			uuidv4();
			const endTime = performance.now();
			const executionTime = endTime - startTime;
			expect(executionTime).toBeLessThan(1);
		});

		// uses cryptographically secure random bytes
		it('should use cryptographically secure random bytes', () => {
			const result = uuidv4();
			// Check if the result is a valid hexadecimal string
			expect(/^[0-9a-fA-F]+$/.test(result)).toBe(true);
		});

		// works in both Node.js and browser environments
		it('should work in both Node.js and browser environments', () => {
			// No specific behavior to test, as the code is already written to work in both environments
			expect(true).toBe(true);
		});
	});


	describe('SpeedFormatter', () => {

		// Format 0 bytes returns { value: 0, unit: "B/s" }
		it('should return { value: 0, unit: "B/s" } when formatting 0 bytes', () => {
			expect(SpeedFormatter.formatUnit(0)).toEqual({ value: 0, unit: "B/s" });
		});

		// Format 1023 bytes returns { value: 1023, unit: "B/s" }
		it('should return { value: 1023, unit: "B/s" } when formatting 1023 bytes', () => {
			expect(SpeedFormatter.formatUnit(1023)).toEqual({ value: 1023, unit: "B/s" });
		});

		// Format 1 kilobyte returns { value: 1, unit: "KB/s" }
		it('should return { value: 1, unit: "KB/s" } when formatting 1 kilobyte', () => {
			expect(SpeedFormatter.formatUnit(1024)).toEqual({ value: 1, unit: "KB/s" });
		});

		// Format Number.MAX_SAFE_INTEGER bytes returns { value: Number.MAX_SAFE_INTEGER, unit: "B/s" }
		it('should return { value: Number.MAX_SAFE_INTEGER, unit: "GB/s" } when formatting Number.MAX_SAFE_INTEGER bytes', () => {
			const speed = Math.floor(Number.MAX_SAFE_INTEGER) / 1024 ** 3

			const expected = {
				value: Number(speed.toFixed(2)),
				unit: "GB/s"
			}
			expect(SpeedFormatter.formatUnit(Number.MAX_SAFE_INTEGER)).toEqual(expected);
		});

		// Format Number.MIN_SAFE_INTEGER bytes returns { value: Number.MIN_SAFE_INTEGER, unit: "B/s" }
		it('should return { value: Number.MIN_SAFE_INTEGER, unit: "B/s" } when formatting Number.MIN_SAFE_INTEGER bytes', () => {
			expect(SpeedFormatter.formatUnit(Number.MIN_SAFE_INTEGER)).toEqual({ value: Number.MIN_SAFE_INTEGER, unit: "B/s" });
		});
	});


	describe('FileHelper', () => {

		// Use promisify to convert fs methods to use promises
		const statPromisify = util.promisify(fs.stat);

		describe('ensureDir', () => {
			// ensureDir resolves if directory already exists
			it('should resolve when directory already exists', async () => {
				// Arrange
				const directory = 'result_test/path/to/directory';
				const fsMock = {
					stat: jest.fn((path, callback) => {
						callback(null);
					}),
					mkdir: jest.fn((path, options, callback) => {
						callback();
					})
				};
				jest.mock('fs', () => fsMock);

				// Act & Assert
				await expect(FileHelper.ensureDir(directory)).resolves.toBeUndefined();
			});

			it('should ensure that a directory exists', async () => {
				const directory = 'result_test/test-directory';

				// Ensure the directory does not exist initially
				try {
					await statPromisify(directory);
					// If it exists, remove it to simulate non-existence
					await fs.promises.rmdir(directory);
				} catch (error) {
					// Directory doesn't exist, continue
				}

				await FileHelper.ensureDir(directory);

				// Verify that the directory now exists
				const stats = await statPromisify(directory);
				expect(stats.isDirectory()).toBe(true);
			});
		});

		describe('getFileName', () => {
			it('should extract the file name from a URL', () => {
				const url = 'https://example.com/path/to/file.txt';
				const fileName = FileHelper.getFileName(url);
				expect(fileName).toBe('file.txt');
			});

			it('should return an empty string when URL does not contain file name', () => {
				const url = 'https://example.com/path/to/';
				const result = FileHelper.getFileName(url);
				expect(result).toBe('');
			});

			it('should handle URLs with query parameters', () => {
				const url = 'https://example.com/path/to/file.txt?version=1';
				const fileName = FileHelper.getFileName(url);
				expect(fileName).toBe('file.txt');
			});
		});
	})

});
